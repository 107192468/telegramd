/*
 *  Copyright (c) 2016, https://github.com/nebula-im
 *  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_multiple_files = true;
option java_package = "com.nebulaim.zproto";
option java_outer_classname = "ZProtoSync";
option optimize_for = CODE_SIZE;

// import "mtproto/schemas/schema.tl.crc32.proto";
// import "mtproto/schemas/schema.tl.core_types.proto";
import "message.proto";
import "github.com/nebulaim/telegramd/mtproto/schemas/schema.tl.sync.proto";

package zproto;


// ## telegram的同步服务思考
//  - telegram消息的同步有两种类型的数据：
//      * 一是消息类服务，此类服务是基于用户的同步，需要进行离线存储，通过pts和qts来进行同步，
//        pts和qts与用户进行绑定（qts是否和用户进行绑定还需要观察）
//      * 另一类是在线推送服务，如果设备终端在线需要推送到客户端设备，
//        一旦推送结束此消息生命周期就结束，并不需要进行离线存储，
//        例如phoneCall握手服务以及修改用户配置后同步到其他客户端设备等，通过seq进行同步
//
//  - 同步服务需要提供给调用方两种类型的接口
//      * 基于用户的推送接口，分两种
//          * 推送到该用户下所有的在线客户端设备
//          * 推送到该用户下除了某一个设备之外的所有其他在线客户端设备
//      * 基于设备的推送接口
//          * 推送给指定设备
//          * 推送到该用户下除了某一个设备之外的所有其他在线客户端设备
//
//  - pts和qts以及seq由sync_server服务生成并维护sync队列
//    > 注意，因为消息服务不维护pts和qts以及seq，但发消息等rpc调用会返回pts以及qts和seq，
//    > sync_server还要提供一些接口给消息服务获取pts和qts以及seq
//

// 同步类型
enum SyncType {
    SYNC_TYPE_UNKNOWN               = 0;        // unknown
    SYNC_TYPE_USER                  = 1;        // 该用户所有设备
    SYNC_TYPE_USER_NOTME            = 2;        // 该用户除了某个设备
    SYNC_TYPE_AUTH_KEY              = 3;        // 发送给指定设备
    SYNC_TYPE_AUTH_KEY_USER         = 4;        // 该用户所有设备
    SYNC_TYPE_AUTH_KEY_USERNOTME    = 5;        // 该用户除了某个设备
}

///////////////////////////////////////////////////////////////////////
// ServerAuthReq ==> VoidRsp
// SERVER_AUTH_REQ
message ServerAuthReq {
    int32  server_id = 1;
    string server_name = 2;
}

message PushUpdatesData {
    int64 auth_key_id = 1;
    int64 session_id = 2;
    int64 netlib_session_id = 3;
    uint32 raw_data_header = 4;
    bytes  raw_data = 5;
}

//
message DeliveryUpdatesToUsers {
    int64 my_auth_key_id = 1;
    int64 my_session_id = 2;
    int64 my_netlib_session_id = 3;
    repeated int32  sendto_user_id_list = 4;
    // uint32 raw_data_header = 4;
    bytes  raw_data = 5;
}

///////////////////////////////////////////////////////////////////////
message PushShortMessage {
    SyncType push_type = 1;
    int32 push_user_id = 2;
    mtproto.TL_updateShortMessage push_data= 3;
}
// UpdateShortMessageRequest --> DeliveryRsp
message UpdateShortMessageRequest {
    int64 sender_auth_key_id = 1;
    int64 sender_session_id = 2;
    int64 sender_netlib_session_id = 3;
    int32 sender_user_id = 4;
    int32 peer_user_id = 5;     // sender_user_id == peer_user_id检查是否是发送给自己
    repeated PushShortMessage push_datas = 6;
}

message PushShortChatMessage {
    SyncType push_type = 1;
    int32 push_user_id = 2;
    mtproto.TL_updateShortChatMessage push_data= 3;
}

// UpdatShortChatMessageRequest --> DeliveryRsp
message UpdatShortChatMessageRequest {
    int64 sender_auth_key_id = 1;
    int64 sender_session_id = 2;
    int64 sender_netlib_session_id = 3;
    int32 sender_user_id = 4;
    int32 peer_chat_id = 5;

    // 首记录为发送者
    repeated PushShortChatMessage push_datas = 6;
    // repeated int32  peer_user_id_list = 6;
    // mtproto.TL_updateShortChatMessage peer_updates = 7;
}

message PushUpdates {
    SyncType push_type = 1;
    int32 push_user_id = 2;
    mtproto.TL_updates push_data = 3;
}

// UpdatesRequest --> DeliveryRsp
message UpdatesRequest {
    int64 sender_auth_key_id = 1;
    int64 sender_session_id = 2;
    int64 sender_netlib_session_id = 3;
    int32 sender_user_id = 4;
    repeated PushUpdates push_datas = 5;
}

message DeliveryRsp {
    int32 date = 1;
    int32 pts = 2;
    int32 pts_count = 3;
    int32 qts = 4;
    int32 seq_start = 5;
    int32 seq =6;
}

// Interface exported by the server.
service RPCSync {
    // frontend --> sync
    rpc PushUpdatesStream(ServerAuthReq) returns (stream PushUpdatesData);

    // rpc ServerAuth(ServerAuthReq) returns (VoidRsp);
    rpc DeliveryUpdates(DeliveryUpdatesToUsers) returns (VoidRsp);
    rpc DeliveryUpdatesNotMe(DeliveryUpdatesToUsers) returns (VoidRsp);

    // DeliveryUpdateShortMessage
    rpc DeliveryUpdateShortMessage(UpdateShortMessageRequest) returns (DeliveryRsp);
    rpc DeliveryUpdatShortChatMessage(UpdatShortChatMessageRequest) returns (DeliveryRsp);
    rpc DeliveryUpdates2(UpdatesRequest) returns (DeliveryRsp);
}
